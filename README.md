# design-patterns

Design pattern concepts and implementation in Javascript

## 创建型模式

> 工厂方法模式

-   **模式意图**：通过在父类中提供创建对象的方法，让子类来决定实例化对象的类型。
-   **适用场景**：

> 抽象工厂模式

-   **模式意图**：通过对工厂类进行抽象，来实现在不需要指定具体工厂类的情况下，创建一系列相关的对象。
-   **适用场景**：

> 生成器模式

-   **模式意图**：通过分步的方式，实现相同创建代码可以生成不同类型和形式的对象。
-   **适用场景**：

> 原型模式

-   **模式意图**：在代码不需要依赖已有对象所属父类的情况下，实现对已有对象的复制。
-   **适用场景**：

> 单例模式

-   **模式意图**：确保一个类只有一个实例，并提供一个访问该实例的全局节点。
-   **适用场景**：

## 结构型模式

> 适配器模式

-   **模式意图**：使接口不兼容的对象能够彼此相互合作。
-   **适用场景**：

> 桥接模式

-   **模式意图**：通过将一个大类或一系列紧密相关的类拆分为**抽象**和**实现**两个独立的层次结构，来实现在开发中分别使用。
-   **适用场景**：

> 组合模式

-   **模式意图**：通过将多个对象组合成树状结构，来实现如同一个独立对象一样使用它们。
-   **适用场景**：

> 装饰模式

-   **模式意图**：通过将对象放入包含行为的特殊封装对象中，来为原对象绑定新的行为。
-   **适用场景**：

> 外观模式

-   **模式意图**：为程序库、框架或者其它复杂类提供一种简单的对外接口。
-   **适用场景**：

> 享元模式

-   **模式意图**：通过对多个对象共有**数据**的提取，使得多个对象共享他们相同状态，来实现在有限内存中加载更多对象。
-   **适用场景**：

> 代理模式

-   **模式意图**：通过提供原对象的代理（替代对象或占位符的），让代理控制原对象的访问，实现在请求提交给原对象前后进行一些操作
-   **适用场景**：

## 行为模式

> 责任链模式

-   **模式意图**：通过将请求沿着处理者链路进行发送，收到请求后，处理者均可对请求进行处理，或将请求传递给链路上下一个处理者。
-   **适用场景**：

> 命令模式

-   **模式意图**：通过将请求封装成一个包含该请求所有信息的独立对象，来实现不同请求方法的参数化、延迟执行或放入队列中实现请求组合，并且支持撤销操作。
-   **适用场景**：

> 迭代器模式

-   **模式意图**：让你在不暴露集合底层数据类型(Array、Stack 或 Map 等)的情况下，遍历集合中所有元素。
-   **适用场景**：

> 中介者模式

-   **模式意图**：通过迫使多个对象通过一个中介者对象进行合作，限制多个对象彼此之间的直接交互，来减少对象间混乱无序的依赖关系。
-   **适用场景**：

> 备忘录模式

-   **模式意图**：允许在不暴露实现细节情况下**保存**和**恢复**对象之前的状态。
-   **适用场景**：

> 观察者模式

-   **模式意图**：通过订阅机制，可以在指定对象发生变化时通知多个观察该对象的观察者对象。
-   **适用场景**：

> 状态模式

-   **模式意图**：在一个对象内部状态变化时改变该对象的行为，看上去就像改变了对象自身所属的类一样。
-   **适用场景**：

> 策略模式

-   **模式意图**：通过定义一系列算法，并将每种算法分别放入独立的类中，使得算法的对象可以相互替换。
-   **适用场景**：

> 模板方法模式

-   **模式意图**：在超类中定义一个算法的框架，允许子类在不修改结构的情况下重写算法的特性步骤。
-   **适用场景**：

> 访问者模式

-   **模式意图**：将算法与其所作用的对象隔离开。
-   **适用场景**：
